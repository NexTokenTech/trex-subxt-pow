# TREX library to submit dTRE data to TREX nodes
This is a library to pack up decentralized timed-release encrpytion (dTRE) data as a form of blockchain extrinsics and send it to TREX nodes.

This library could be integrated with any frontend web applications or rust-based backend servers to submit dTRE data to the TREX network.

### Create a TREX subxt API
We will be creating a rust app to submit dTRE data. So, to create a rust app follow the following steps in the terminal. First, you need to get your system ready. So install some packages to begin.

#### 1.create an application app for rust.

#### 2.add dependences like below:
``` rust
[dependencies]
subxt = "0.18.1"
async-std = { version = "1.9.0", features = ["attributes", "tokio1"] }
sp-keyring = "6.0.0"
env_logger = "0.9.0"
futures = "0.3.13"
codec = { package = "parity-scale-codec", version = "3.0.0", default-features = false, features = ["derive", "full", "bit-vec"] }
hex = "0.4.3"
```

#### 3.Install subxt-cli:
``` rust
cargo install subxt-cli
``` 

#### 4.Save the encoded metadata to a file:
``` rust
subxt metadata -f bytes > metadata.scale
``` 

#### 5.Generating the runtime API from the downloaded metadata
Declare a module and decorate it with the subxt attribute which points at the downloaded metadata for the target runtime:
``` rust
#[subxt::subxt(runtime_metadata_path = "metadata.scale")]
pub mod capsule { }
```
Important: runtime_metadata_path resolves to a path relative to the directory where your crate's Cargo.toml resides (CARGO_MANIFEST_DIR), not relative to the source file.

#### 6.Initializing the API client
``` rust
use subxt::{ClientBuilder, DefaultConfig, DefaultExtra};

let api = ClientBuilder::new()
    .set_url("wss://rpc.polkadot.io:443")
    .build()
    .await?
    .to_runtime_api::<capsule::RuntimeApi<DefaultConfig, DefaultExtra<DefaultConfig>>>();
``` 

The *RuntimeApi* type is generated by the *subxt* macro from the supplied metadata. This can be parameterized with user supplied implementations for the **Config** and **Extra** types, if the default implementations differ from the target chain.

#### 7.Submitting Extrinsics
Submit an extrinsic, returning success once the transaction is validated and accepted into the pool:
``` rust
use sp_keyring::AccountKeyring;
use subxt::PairSigner;

let signer = PairSigner::new(AccountKeyring::Alice.pair());
let acount_id = AccountKeyring::Alice.to_account_id().into();

let str = "second vec u8 message2".as_bytes();
let hash = api
        .tx()
        .capsule_module()
        .send_capsule_data(acount_id,str.to_vec(),1023)
        .sign_and_submit(&signer)
        .await?;
``` 

For more advanced usage, which can wait for block inclusion and return any events triggered by the extrinsic.
